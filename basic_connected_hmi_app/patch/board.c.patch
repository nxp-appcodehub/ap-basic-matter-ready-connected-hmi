diff --git a/examples/platform/nxp/rt/rt1060/board/board.c b/examples/platform/nxp/rt/rt1060/board/board.c
index a6f374d294..ef3ac6a981 100644
--- a/examples/platform/nxp/rt/rt1060/board/board.c
+++ b/examples/platform/nxp/rt/rt1060/board/board.c
@@ -13,9 +13,51 @@
 #endif /* SDK_I2C_BASED_COMPONENT_USED */
 #include "fsl_iomuxc.h"
 
+#include <stdio.h>
+#include <string.h>
+#ifdef ENABLE_CHIP_SHELL
+#include "fsl_component_serial_manager.h"
+#endif
+
+#ifdef ENABLE_CHIP_SHELL
+#ifndef STREAMER_UART_SERIAL_MANAGER_RING_BUFFER_SIZE
+#define STREAMER_UART_SERIAL_MANAGER_RING_BUFFER_SIZE (128U)
+#endif
+
+#ifndef STREAMER_UART_FLUSH_DELAY_MS
+#define STREAMER_UART_FLUSH_DELAY_MS 2
+#endif
+
+#ifndef BOARD_APP_UART_CLK_FREQ
+#define BOARD_APP_UART_CLK_FREQ BOARD_BT_UART_CLK_FREQ
+#endif
+#endif /* ENABLE_CHIP_SHELL */
+
 /*******************************************************************************
  * Variables
  ******************************************************************************/
+#ifdef ENABLE_CHIP_SHELL
+static SERIAL_MANAGER_HANDLE_DEFINE(streamerSerialHandle);
+static SERIAL_MANAGER_WRITE_HANDLE_DEFINE(streamerSerialWriteHandle);
+static SERIAL_MANAGER_READ_HANDLE_DEFINE(streamerSerialReadHandle);
+static volatile int txCount = 0;
+static bool readDone = false;
+
+static serial_port_uart_config_t uartConfig = {0};
+
+static uint8_t s_ringBuffer[STREAMER_UART_SERIAL_MANAGER_RING_BUFFER_SIZE];
+static const serial_manager_config_t s_serialManagerConfig = {
+    .ringBuffer     = &s_ringBuffer[0],
+    .ringBufferSize = STREAMER_UART_SERIAL_MANAGER_RING_BUFFER_SIZE,
+    .type           = BOARD_DEBUG_UART_TYPE,
+    .blockType      = kSerialManager_NonBlocking,
+    .portConfig     = (serial_port_uart_config_t *)&uartConfig,
+};
+
+static bool isSerialInitialized = false;
+#endif
+
+static bool isDebugInitialized = false;
 /*******************************************************************************
  * Code
  ******************************************************************************/
@@ -39,12 +81,167 @@ uint32_t BOARD_DebugConsoleSrcFreq(void)
     return freq;
 }
 
+/* -------------------------------------------------------------------------- */
+/*                              Private functions                             */
+/* -------------------------------------------------------------------------- */
+#ifdef ENABLE_CHIP_SHELL
+
+/* RX callback for the Matter CLI Task processing */
+extern TaskHandle_t AppMatterCliTaskHandle;
+static void Uart_RxCallBack(void *pData, serial_manager_callback_message_t *message, serial_manager_status_t status)
+{
+    if (AppMatterCliTaskHandle != NULL)
+    {
+        /* notify the main loop that a RX buffer is available */
+        xTaskNotifyGive(AppMatterCliTaskHandle);
+    }
+}
+
+/* TX callback for Serial Manager */
+static void Uart_TxCallBack(void *pBuffer, serial_manager_callback_message_t *message, serial_manager_status_t status)
+{
+    txCount--;
+}
+
+/* Serial manager initialization function */
+serial_manager_status_t serial_init(uint8_t instance)
+{
+    serial_manager_status_t status = kStatus_SerialManager_Success;
+
+    if (!isSerialInitialized)
+    {
+        uartConfig.clockRate    = BOARD_APP_UART_CLK_FREQ;
+        uartConfig.baudRate     = BOARD_DEBUG_UART_BAUDRATE;
+        uartConfig.parityMode   = kSerialManager_UartParityDisabled;
+        uartConfig.stopBitCount = kSerialManager_UartOneStopBit;
+        uartConfig.enableRx     = 1;
+        uartConfig.enableTx     = 1;
+        uartConfig.enableRxRTS  = 0;
+        uartConfig.enableTxCTS  = 0;
+        uartConfig.instance     = instance;
+
+        /*
+         * Make sure to disable interrupts while initializating the serial manager interface
+         * Some issues could happen if a UART IRQ is firing during serial manager initialization
+         */
+        OSA_InterruptDisable();
+
+        do
+        {
+            if (SerialManager_Init((serial_handle_t)streamerSerialHandle, &s_serialManagerConfig) !=
+                kStatus_SerialManager_Success)
+                break;
+            if (SerialManager_OpenWriteHandle((serial_handle_t)streamerSerialHandle,
+                                              (serial_write_handle_t)streamerSerialWriteHandle) !=
+                kStatus_SerialManager_Success)
+                break;
+            if (SerialManager_OpenReadHandle((serial_handle_t)streamerSerialHandle,
+                                             (serial_read_handle_t)streamerSerialReadHandle) != kStatus_SerialManager_Success)
+                break;
+            if (SerialManager_InstallRxCallback((serial_read_handle_t)streamerSerialReadHandle, Uart_RxCallBack, NULL) !=
+                kStatus_SerialManager_Success)
+                break;
+            if (SerialManager_InstallTxCallback((serial_write_handle_t)streamerSerialWriteHandle, Uart_TxCallBack, NULL) !=
+                kStatus_SerialManager_Success)
+                break;
+            status = kStatus_SerialManager_Success;
+        } while (0);
+
+        OSA_InterruptEnable();
+        isSerialInitialized = true;
+    }
+
+    return status;
+}
+
+/* Serial read function for Matter CLI */
+ssize_t serial_read(char * buffer, size_t length)
+{
+    uint32_t bytesRead = 0;
+    serial_manager_status_t status = kStatus_SerialManager_Success;
+
+    if (length != 0)
+    {
+        /**
+         * If the reading process is over,
+         * let CLI Task enter blocked state until notification
+        **/
+        if (readDone)
+        {
+            ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
+            readDone = false;
+        }
+
+        status = SerialManager_TryRead((serial_read_handle_t)streamerSerialReadHandle, (uint8_t *)buffer, length, &bytesRead);
+        assert(status != kStatus_SerialManager_Error);
+
+        /**
+         * If we are at the end of the line or the buffer is empty,
+         * consider the reading process done
+        **/
+        if ((buffer[length-1] == '\n') || (buffer[length-1] == '\r') || (bytesRead == 0))
+        {
+            readDone = true;
+        }
+    }
+
+    return bytesRead;
+}
+#endif /* ENABLE_CHIP_SHELL */
+
+extern bool getResetInIdleValue(void);
+
+/* Serial write function for Matter CLI and Matter logs */
+ssize_t serial_write(const char * buffer, size_t length)
+{
+    size_t len = 0;
+
+#ifdef ENABLE_CHIP_SHELL
+    bool isResetScheduled = getResetInIdleValue();
+
+    if ((isSerialInitialized) && (!isResetScheduled))
+    {
+        uint32_t intMask;
+        serial_manager_status_t status = kStatus_SerialManager_Error;
+
+        /* Make sure that no TX is already sent */
+        while(txCount);
+
+        intMask = DisableGlobalIRQ();
+        txCount++;
+        status = SerialManager_WriteNonBlocking((serial_write_handle_t)streamerSerialWriteHandle, (uint8_t *)buffer, (uint32_t) length);
+        EnableGlobalIRQ(intMask);
+        if (status == kStatus_SerialManager_Success)
+        {
+            len = length;
+        }
+
+        /* Wait for the serial manager task to empty the TX buffer */
+        while (txCount)
+        {
+            OSA_TimeDelay(STREAMER_UART_FLUSH_DELAY_MS);
+        }
+    }
+    else
+#endif /* ENABLE_CHIP_SHELL */
+    {
+        PRINTF("%s", buffer);
+        len = length;
+    }
+
+    return len;
+}
+
 /* Initialize debug console. */
 void BOARD_InitDebugConsole(void)
 {
-    uint32_t uartClkSrcFreq = BOARD_DebugConsoleSrcFreq();
-
-    DbgConsole_Init(BOARD_DEBUG_UART_INSTANCE, BOARD_DEBUG_UART_BAUDRATE, BOARD_DEBUG_UART_TYPE, uartClkSrcFreq);
+    if (!isDebugInitialized)
+    {
+        /* We first init the debug console which is directly using the UART driver */
+        uint32_t uartClkSrcFreq = BOARD_DebugConsoleSrcFreq();
+        DbgConsole_Init(BOARD_DEBUG_UART_INSTANCE, BOARD_DEBUG_UART_BAUDRATE, BOARD_DEBUG_UART_TYPE, uartClkSrcFreq);
+        isDebugInitialized = true;
+    }
 }
 
 #if defined(SDK_I2C_BASED_COMPONENT_USED) && SDK_I2C_BASED_COMPONENT_USED
